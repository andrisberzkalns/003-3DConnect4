import { signIn, signOut, useSession } from "next-auth/react";
import Head from "next/head";
import Link from "next/link";
import React, { useCallback } from "react";
import * as THREE from 'three';
import { CameraControls,  Center, PerspectiveCamera, Stage, Stars, Text3D, useFont, Environment, useGLTF, useHelper, SoftShadows, MeshTransmissionMaterial, BakeShadows } from '@react-three/drei'

import { api } from "~/utils/api";
import { Canvas, useFrame } from '@react-three/fiber'
import { BoardWithPieces } from "~/components/BoardWithPieces";
import { BoardSelections } from "~/components/BoardSelections";
import { Piece } from "~/components/Piece";
import { getNextPieceHeight } from "~/utils/getNextPieceHeight";
import { CSpotLight, CAmbientLight } from "~/components/Lights";
// import { PieceInstance } from "~/components/Pieces/PieceInstance";
import { EGameState, TGameData, EPlayer, ESquareState } from "~/utils/gameTypes";
import { checkIsWin } from "~/utils/checkIsWin";

const SETTINGS = {
  SHADOW_QUALITY: 1 // 0 - off, 1 - on, 2 - soft shadows, 3 - high quality soft shadows
}

export default function Home() {
  const hello = api.example.hello.useQuery({ text: "from tRPC" });

  return (
    <>
      <Head>
        <title>Create T3 App</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="flex min-h-screen bg-gradient-to-b from-yellow-500 to-orange-900">
        <div className="w-screen h-screen">
          <Canvas shadows>
            <Scene/>
          </Canvas>
        </div>
      </main>
    </>
  );
}

const Scene: React.FC = () => {
  const [gameData, setGameData] = React.useState<TGameData>({
    state: EGameState.Playing,
    turn: EPlayer.Light,
    board: Array.from({length: 4}).map(() => Array.from({length: 4}).map(() => Array.from({length: 4}).map(() => ESquareState.Empty)))
  });

  const addPiece = (positionVector: THREE.Vector2) => {
    setGameData((prevState: TGameData) => {
      if (gameData.state !== EGameState.Playing && gameData.state != EGameState.Animating) return prevState;
      const newState: TGameData = structuredClone(prevState);
      const pieceHeight = getNextPieceHeight(newState, positionVector.x, positionVector.y);
      if (pieceHeight > 3) return prevState;
      newState.board[positionVector.x]![positionVector.y]![pieceHeight] = prevState.turn == EPlayer.Light ? ESquareState.Light : ESquareState.Dark;
      if (newState.turn == EPlayer.Light) {
        newState.turn = EPlayer.Dark;
      } else {
        newState.turn = EPlayer.Light;
      }

      const isWin = checkIsWin(newState);
      if (isWin) {
        console.log("There is a win");
        if (isWin.winningCoordinates) {
          isWin.winningCoordinates.forEach((coord) => {
            newState.board[coord.x]![coord.y]![coord.z] = isWin.result == EGameState.LightWin ? ESquareState.LightHighlighted : ESquareState.DarkHighlighted;
          });
        }
        newState.state = isWin.result;
      }

      return newState;
    });
  }

  const removePiece = (positionVector: THREE.Vector2) => {
    setGameData((prevState) => {
      if (gameData.state !== EGameState.Animating && gameData.state !== EGameState.Playing) return prevState;
      const newState = structuredClone(prevState);
      const pieceHeight = getNextPieceHeight(newState, positionVector.x, positionVector.y);
      if (pieceHeight < 0) return prevState;
      newState.board[positionVector.x]![positionVector.y]![pieceHeight - 1] = ESquareState.Empty;
      return newState;
    });
  }

  const setLightWin = () => {
    setGameData((prevState) => {
      const newState = structuredClone(prevState);
      newState.state = EGameState.LightWin;
      return newState;
    });
  }

  const setDarkWin = () => {
    setGameData((prevState) => {
      const newState = structuredClone(prevState);
      newState.state = EGameState.DarkWin;
      return newState;
    });
  }

  // useFrame((frame) => {
  //   const { clock } = frame;
  //   if (gameData.state !== EGameState.Animating) return;

    // Lines add remove
    // addPiece(new THREE.Vector2(Math.floor(clock.elapsedTime % 2 * 2), Math.floor(clock.elapsedTime / 4 % 2 * 2)));
    // removePiece(new THREE.Vector2(Math.floor((clock.elapsedTime + 10) % 2 * 2), Math.floor((clock.elapsedTime + 10) / 4 % 2 * 2)));

    // Random add remove
    // addPiece(new THREE.Vector2(Math.floor(Math.random() * 4), Math.floor(Math.random() * 4)));
    // removePiece(new THREE.Vector2(Math.floor(Math.random() * 4), Math.floor(Math.random() * 4)));

    // Cross pattern add remove
    // if (Math.floor(clock.elapsedTime) % 6 < 3) {
    //   addPiece(new THREE.Vector2(0, 0));
    //   addPiece(new THREE.Vector2(3, 3));
    //   addPiece(new THREE.Vector2(0, 3));
    //   addPiece(new THREE.Vector2(3, 0));
    //   removePiece(new THREE.Vector2(1, 1));
    //   removePiece(new THREE.Vector2(1, 2));
    //   removePiece(new THREE.Vector2(2, 1));
    //   removePiece(new THREE.Vector2(2, 2));
    // } else {
    //   addPiece(new THREE.Vector2(1, 1));
    //   addPiece(new THREE.Vector2(2, 2));
    //   addPiece(new THREE.Vector2(2, 1));
    //   addPiece(new THREE.Vector2(1, 2));
    //   removePiece(new THREE.Vector2(0, 0));
    //   removePiece(new THREE.Vector2(3, 0));
    //   removePiece(new THREE.Vector2(0, 3));
    //   removePiece(new THREE.Vector2(3, 3));
    // }
  // });

  return (
    <>
      <CSpotLight 
        position={[3,6,3]}
        visible={true}
        color={"#FFDDB5"}
        intensity={100}
        castShadow={true}
      />
      <CSpotLight
        position={[-3, 6, 3]}
        visible={true}
        color={"#FFDDB5"}
        intensity={100}
        castShadow={true}
      />
      <CAmbientLight
        color={"#FFDDB5"}
        intensity={0.5}
      />

      {/* <PerspectiveCamera
        makeDefault
        position={[0, 0.8, 5]}
        fov={75}
        aspect={2}
        near={0.1}
        far={1000}
      /> */}
      <CameraControls/>
      <React.Suspense fallback={null}>
        <BoardWithPieces/>
        {
          gameData.board.map((row, i) => {
            return row.map((col, j) => {
              return col.map((square, k) => {
                if (square == ESquareState.Empty) return (<></>);
                return <Piece key={`${i}${j}${k}`} pos={new THREE.Vector3(i, j, k)} square={square}/>
              });
            })
          })
        }
        {
          SETTINGS.SHADOW_QUALITY > 1 && (<SoftShadows size={60} samples={8} focus={0.5}/>)
        }
        {/* <BakeShadows /> */}
        <BoardSelections addPiece={addPiece}/>
      </React.Suspense>
    </>
  )
}

